#!/usr/bin/env python
from misc.utility.scons_hints import *
from custom.utils import *

Import("env")

import os

import core_builders

import methods

env.core_sources = []


# Add required thirdparty code.
log_info("build core")

thirdparty_obj = []

env_thirdparty = env.Clone()
env_thirdparty.disable_warnings()

# Misc thirdparty code: header paths are hardcoded, we don't need to append
# to the include path (saves a few chars on the compiler invocation for touchy MSVC...)
thirdparty_misc_dir = "#thirdparty/misc/"
thirdparty_misc_sources = [
    # C sources
    "fastlz.c",
    "r128.c",
    "smaz.c",
    # C++ sources
    "pcg.cpp",
    "polypartition.cpp",
    "smolv.cpp",
]
thirdparty_misc_sources = [thirdparty_misc_dir + file for file in thirdparty_misc_sources]
env_thirdparty.add_source_files(thirdparty_obj, thirdparty_misc_sources)

if env["brotli"] and env["builtin_brotli"]:
    thirdparty_brotli_dir = "#thirdparty/brotli/"
    brotli_lib_path = thirdparty_brotli_dir + "build"
    brotli_include_path = thirdparty_brotli_dir + "include"

    # 加入头文件路径
    env.Prepend(CPPPATH=[brotli_include_path])
    brotli_lib = os.path.join(brotli_lib_path, "brotli.lib")
    # 添加Brotli库到链接中
    env.Append(LINKFLAGS=[env.File(brotli_lib).abspath])

if env["builtin_clipper2"]:
    thirdparty_clipper_dir = "#thirdparty/clipper2/"
    thirdparty_clipper_lib_dir = thirdparty_clipper_dir + "build/"
    thirdparty_clipper_include_dir = thirdparty_clipper_dir + "include"

    env.Prepend(CPPPATH=[thirdparty_clipper_include_dir])
    env.Append(LIBPATH=[thirdparty_clipper_lib_dir])
    env.Append(LINKFLAGS=["clipper2.lib"])

    # 推荐显式定义宏（虽然CMake已经定义了）
    env.Append(CPPDEFINES=["CLIPPER2_ENABLED"])
    log_info("CLIPPER2_ENABLED")

# Zlib library, built via CMake
if env["builtin_zlib"]:
    log_info("builtin_zlib (CMake build)")
    thirdparty_zlib_dir = "#thirdparty/zlib/"
    thirdparty_zlib_build_dir = thirdparty_zlib_dir + "build/"
    env.Prepend(CPPPATH=[thirdparty_zlib_dir])
    env.Append(LIBPATH=[thirdparty_zlib_build_dir])
    env.Append(LINKFLAGS=["zlib.lib"])

    if env.dev_build:
        log_info("ZLIB_DEBUG")
        env.Append(CPPDEFINES=["ZLIB_DEBUG"])

# Minizip library, built via CMake
thirdparty_minizip_dir = "#thirdparty/minizip/"
thirdparty_minizip_build_dir = thirdparty_minizip_dir + "build/"
env.Prepend(CPPPATH=[thirdparty_minizip_dir])
env.Append(LIBPATH=[thirdparty_minizip_build_dir])
env.Append(LINKFLAGS=["minizip.lib"])


if env["builtin_zstd"]:
    thirdparty_zstd_dir = "#thirdparty/zstd/"
    thirdparty_zstd_build_dir = thirdparty_zstd_dir + "build/"
    env.Prepend(CPPPATH=[thirdparty_zstd_dir, thirdparty_zstd_dir + "common"])
    env.Append(CPPDEFINES=["ZSTD_STATIC_LINKING_ONLY"])
    env.Append(LIBPATH=[thirdparty_zstd_build_dir])
    env.Append(LINKFLAGS=["zstd.lib"])

    log_info("Using Zstd library built via CMake (static linking).")



env.core_sources += thirdparty_obj


# Godot source files

env.add_source_files(env.core_sources, "*.cpp")


# Generate disabled classes
def disabled_class_builder(target, source, env):
    with methods.generated_wrapper(target) as file:
        for c in source[0].read():
            cs = c.strip()
            if cs != "":
                file.write(f"#define ClassDB_Disable_{cs} 1\n")


env.CommandNoCache("disabled_classes.gen.h", env.Value(env.disabled_classes), env.Run(disabled_class_builder))


# Generate version info
def version_info_builder(target, source, env):
    with methods.generated_wrapper(target) as file:
        file.write(
            """\
#define VERSION_SHORT_NAME "{short_name}"
#define VERSION_NAME "{name}"
#define VERSION_MAJOR {major}
#define VERSION_MINOR {minor}
#define VERSION_PATCH {patch}
#define VERSION_STATUS "{status}"
#define VERSION_BUILD "{build}"
#define VERSION_MODULE_CONFIG "{module_config}"
#define VERSION_WEBSITE "{website}"
#define VERSION_DOCS_BRANCH "{docs_branch}"
#define VERSION_DOCS_URL "https://docs.godotengine.org/en/" VERSION_DOCS_BRANCH
""".format(**env.version_info)
        )


env.CommandNoCache("version_generated.gen.h", env.Value(env.version_info), env.Run(version_info_builder))


# Generate version hash
def version_hash_builder(target, source, env):
    with methods.generated_wrapper(target) as file:
        file.write(
            """\
#include "core/version.h"

const char *const VERSION_HASH = "{git_hash}";
const uint64_t VERSION_TIMESTAMP = {git_timestamp};
""".format(**env.version_info)
        )


gen_hash = env.CommandNoCache(
    "version_hash.gen.cpp", env.Value(env.version_info["git_hash"]), env.Run(version_hash_builder)
)
env.add_source_files(env.core_sources, gen_hash)


# Generate AES256 script encryption key
def encryption_key_builder(target, source, env):
    with methods.generated_wrapper(target) as file:
        file.write(
            f"""\
#include "core/config/project_settings.h"

uint8_t script_encryption_key[32] = {{
	{source[0]}
}};"""
        )


gdkey = os.environ.get("SCRIPT_AES256_ENCRYPTION_KEY", "0" * 64)
log_info("gdkey:"+gdkey)
ec_valid = len(gdkey) == 64
if ec_valid:
    try:
        gdkey = ", ".join([str(int(f"{a}{b}", 16)) for a, b in zip(gdkey[0::2], gdkey[1::2])])
    except Exception:
        ec_valid = False
if not ec_valid:
    methods.print_error(
        f'Invalid AES256 encryption key, not 64 hexadecimal characters: "{gdkey}".\n'
        "Unset `SCRIPT_AES256_ENCRYPTION_KEY` in your environment "
        "or make sure that it contains exactly 64 hexadecimal characters."
    )
    Exit(255)
gen_encrypt = env.CommandNoCache("script_encryption_key.gen.cpp", env.Value(gdkey), env.Run(encryption_key_builder))
env.add_source_files(env.core_sources, gen_encrypt)


# Certificates
env.Depends(
    "#core/io/certs_compressed.gen.h",
    ["#thirdparty/certs/ca-certificates.crt", env.Value(env["builtin_certs"]), env.Value(env["system_certs_path"])],
)
env.CommandNoCache(
    "#core/io/certs_compressed.gen.h",
    "#thirdparty/certs/ca-certificates.crt",
    env.Run(core_builders.make_certs_header),
)

# Authors
env.Depends("#core/authors.gen.h", "../AUTHORS.md")
env.CommandNoCache("#core/authors.gen.h", "../AUTHORS.md", env.Run(core_builders.make_authors_header))

# Donors
env.Depends("#core/donors.gen.h", "../DONORS.md")
env.CommandNoCache("#core/donors.gen.h", "../DONORS.md", env.Run(core_builders.make_donors_header))

# License
env.Depends("#core/license.gen.h", ["../COPYRIGHT.txt", "../LICENSE.txt"])
env.CommandNoCache(
    "#core/license.gen.h",
    ["../COPYRIGHT.txt", "../LICENSE.txt"],
    env.Run(core_builders.make_license_header),
)

# Chain load SCsubs
SConscript("os/SCsub")
SConscript("math/SCsub")
SConscript("crypto/SCsub")
SConscript("io/SCsub")
SConscript("debugger/SCsub")
SConscript("input/SCsub")
SConscript("variant/SCsub")
SConscript("extension/SCsub")
SConscript("object/SCsub")
SConscript("templates/SCsub")
SConscript("string/SCsub")
SConscript("config/SCsub")
SConscript("error/SCsub")
SConscript("mediator/SCsub")

# Build it all as a library
lib = env.add_library("core", env.core_sources)
env.Prepend(LIBS=[lib])

# Needed to force rebuilding the core files when the thirdparty code is updated.
env.Depends(lib, thirdparty_obj)
